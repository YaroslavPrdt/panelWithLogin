{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { FETCH_END } from '../../../actions/fetchActions';\nimport { GET_LIST, GET_ONE, GET_MANY, GET_MANY_REFERENCE, CREATE, UPDATE } from '../../../dataFetchActions';\nimport { CRUD_DELETE_OPTIMISTIC, CRUD_DELETE_MANY_OPTIMISTIC, CRUD_UPDATE_OPTIMISTIC, CRUD_UPDATE_MANY_OPTIMISTIC } from '../../../actions/dataActions';\nimport getFetchedAt from '../../../util/getFetchedAt';\n/**\n * Add new records to the pool, and remove outdated ones.\n *\n * This is the equivalent of a stale-while-revalidate caching strategy:\n * The cached data is displayed before fetching, and stale data is removed\n * only once fresh data is fetched.\n */\n\nexport var addRecordsFactory = function addRecordsFactory(getFetchedAt) {\n  return function (newRecords, oldRecords) {\n    if (newRecords === void 0) {\n      newRecords = [];\n    }\n\n    var newFetchedAt = getFetchedAt(newRecords.map(function (_a) {\n      var id = _a.id;\n      return id;\n    }), oldRecords.fetchedAt);\n    var newRecordsById = newRecords.reduce(function (acc, record) {\n      var _a;\n\n      return __assign({}, acc, (_a = {}, _a[record.id] = record, _a));\n    }, {});\n    var records = Object.keys(newFetchedAt).reduce(function (acc, id) {\n      var _a;\n\n      return __assign({}, acc, (_a = {}, _a[id] = newRecordsById[id] || oldRecords[id], _a));\n    }, {});\n    Object.defineProperty(records, 'fetchedAt', {\n      value: newFetchedAt\n    }); // non enumerable by default\n\n    return records;\n  };\n};\nvar addRecords = addRecordsFactory(getFetchedAt);\nvar initialState = {};\nObject.defineProperty(initialState, 'fetchedAt', {\n  value: {}\n}); // non enumerable by default\n\nexport default (function (previousState, _a) {\n  if (previousState === void 0) {\n    previousState = initialState;\n  }\n\n  var type = _a.type,\n      payload = _a.payload,\n      meta = _a.meta;\n\n  if (type === CRUD_UPDATE_OPTIMISTIC) {\n    var updatedRecord = __assign({}, previousState[payload.id], payload.data);\n\n    return addRecords([updatedRecord], previousState);\n  }\n\n  if (type === CRUD_UPDATE_MANY_OPTIMISTIC) {\n    var updatedRecords = payload.ids.reduce(function (records, id) {\n      return records.concat(previousState[id]);\n    }, []).map(function (record) {\n      return __assign({}, record, payload.data);\n    });\n    return addRecords(updatedRecords, previousState);\n  }\n\n  if (type === CRUD_DELETE_OPTIMISTIC) {\n    var _b = payload.id,\n        removed = previousState[_b],\n        newState = __rest(previousState, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n    Object.defineProperty(newState, 'fetchedAt', {\n      value: previousState.fetchedAt\n    });\n    return newState;\n  }\n\n  if (type === CRUD_DELETE_MANY_OPTIMISTIC) {\n    var newState = Object.entries(previousState).filter(function (_a) {\n      var key = _a[0];\n      return !payload.ids.includes(key);\n    }).reduce(function (obj, _a) {\n      var key = _a[0],\n          val = _a[1];\n\n      var _b;\n\n      return __assign({}, obj, (_b = {}, _b[key] = val, _b));\n    }, {});\n    Object.defineProperty(newState, 'fetchedAt', {\n      value: previousState.fetchedAt\n    });\n    return newState;\n  }\n\n  if (!meta || !meta.fetchResponse || meta.fetchStatus !== FETCH_END) {\n    return previousState;\n  }\n\n  switch (meta.fetchResponse) {\n    case GET_LIST:\n    case GET_MANY:\n    case GET_MANY_REFERENCE:\n      return addRecords(payload.data, previousState);\n\n    case GET_ONE:\n    case UPDATE:\n    case CREATE:\n      return addRecords([payload.data], previousState);\n\n    default:\n      return previousState;\n  }\n});\nexport var getRecord = function getRecord(state, id) {\n  return state[id];\n};","map":null,"metadata":{},"sourceType":"module"}